## Атомарность через CAS (Compare-And-Set):

В основе AtomicInteger лежит низкоуровневый механизм CAS, который выполняется на аппаратном уровне.
CAS проверяет, совпадает ли текущее значение переменной с ожидаемым, и, если совпадает, обновляет его. Всё это происходит за одну неделимую операцию.
Если проверка не проходит, операция повторяется (обычно в цикле) до успешного выполнения.

Текущее значение — это значение переменной, которое в данный момент хранится в памяти.
Ожидаемое значение — это значение, которое мы предполагаем увидеть в этой переменной, основываясь на предыдущем состоянии (то есть, значение, которое мы "ожидаем" в нормальной ситуации без внешнего вмешательства).


## Пошаговый пример, как CAS работает:
Представим себе многопоточную ситуацию, где разные потоки работают с одним AtomicInteger:

Поток А хочет увеличить значение с 10 до 11.

- Поток А вызывает метод compareAndSet(10, 11)
- "Ожидаемое" значение: 10.
- "Текущее" значение: 10 (пока никто его не изменил).
- Результат сравнения: совпадает! Значение обновляется до 11.

В то же время поток B хочет изменить значение с 10 на 20:

- Поток B вызывает compareAndSet(10, 20).
- Но пока поток B готовился выполнить операцию, поток А уже изменил значение с 10 на 11.
- Теперь "текущее" значение: 11, "ожидаемое" значение: 10.
- Результат сравнения: не совпадает! Поток B не обновляет значение.
- Поток B может заново попытаться, обновив своё "ожидаемое" значение (в do while).

